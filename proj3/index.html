<!DOCTYPE html>
<html>
<head>
    <title>Project 2 - CS180</title>
        <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
    </style>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1 class="page-title">CS180 Project 3: Image Warping and Mosaicing</h1>
    <h2 class="page-subtitle">Timothy Park</h2>
    
    <h3 class="section-header">Part A.1: Shoot the Pictures</h3>
    <p class="row-caption">These pictures were taken around different areas of campus, but mainly in Cory
      337. I took multiple pictures of different rooms within the lab.
    </p>
    <div class="image-row">
        <img src="images/A1/cory337B/IMG_8705.JPG" alt="B" width="250">
        <img src="images/A1/cory337B/IMG_8703.JPG" alt="B" width="250">
        <img src="images/A1/cory337B/IMG_8702.JPG" alt="B" width="250">
    </div>
    <div class="image-row">
      <img src="images/A1/cory337D/IMG_8719.JPG" alt="D" width="250">
      <img src="images/A1/cory337D/IMG_8720.JPG" alt="D" width="250">
      <img src="images/A1/cory337D/IMG_8721.JPG" alt="D" width="250">
  </div>
  <div class="image-row">
    <img src="images/A1/jacobs/IMG_8755.JPG" alt="J" width="250">
    <img src="images/A1/jacobs/IMG_8756.JPG" alt="J" width="250">
    <img src="images/A1/jacobs/IMG_8757.JPG" alt="J" width="250">
  </div>

  <h3 class="section-header">Part A.2: Recover Homographies</h3>

    <p class="row-caption">In order to recover the homographies between 2 images, I placed the corresponding points in a matrix so I would be able to performed a least squares operation. We know
      H is a 3x3 matrix, but we can transform the problem such that we are solving for a vector of values. We also know that h9, the value in the 
      bottom right corner, represents the scale. Therefore, we can set it to 1. There are therefore 8 unknowns in the matrix. Therefore, we need at least 4 points to solve for the homography. 
      Below is the equation to compute the homography:
    </p>
    <div class="image-row">
      <figure>
      <img src="images/A2/h.png" alt="h" width="450">
    </figure>
    <figure>
      <img src="images/A2/sys_equations.png" alt="h" width="450">
    </figure>
    </div>
    
    <div class="image-row">
      <figure>
      <img src="images/A2/cory337B/8700.png" alt="4 loops" width="450">
    </figure>

    <figure>
      <img src="images/A2/cory337B/8701_w_8700_pts.png" alt="2 loops" width="450">
    </figure>
    </div>

    <div class="image-row">
      <figure>
      <img src="images/A2/cory337B/h_matrix.png" alt="picture of me" width="450">
    </figure>

    </div>

    <div class="image-row">
      <figure>
      <img src="images/A2/cory337B_2/8703.png" alt="4 loops" width="450">
    </figure>

    <figure>
      <img src="images/A2/cory337B_2/8705_w_8703_pts.png" alt="2 loops" width="450">
    </figure>
    </div>

    <div class="image-row">
      <figure>
      <img src="images/A2/cory337B_2/h_matrix.png" alt="picture of me" width="450">
    </figure>

    </div>

      <div class="image-row">
        <figure>
        <img src="images/A2/cory337D/8720.png" alt="4 loops" width="450">
      </figure>
  
      <figure>
        <img src="images/A2/cory337D/8721_w_8720_pts.png" alt="2 loops" width="450">
      </figure>
      </div>
  
      <div class="image-row">
        <figure>
        <img src="images/A2/cory337D/h_matrix.png" alt="picture of me" width="450">
      </figure>
  
      </div>

      <h3 class="section-header">Part A.3: Warp the Images</h3>

      <p class="row-caption">In order to warp the image, I took the following steps. First, I found the dimensions of the new canvas I was going to put the image onto.
        Then, I applied the homography to the image's pixels in order to get the new pixel locations. First, I used a nearest neighbor interpolation, meaning I simply 
        rounded all the canvas pixel locations to find which pixel from the original image they corresponded to. Then, I used bilinear interpolation, meaning I took the 4 closest
        pixels and weighted them based upon their distance to the pixel I was trying to map. This is how I was able to rectify these images. If a pixel didn't map on to the original image
        before the homography, then I left it as a black pixel. I chose the following 2 images because 
        they have squares in them, so I know which value needs to be at which location without performing manual measurement. I mapped the 4 corners of the square to
        [0,0], [100, 0], [0, 100], and [100, 100] in order to make the square a perfect square.
      </p>

      <div class="image-row">
        <figure>
        <img src="images/A3/aruco/original.JPG" alt="h" width="450">
        <figcaption>original</figcaption>
      </figure>
      <figure>
        <img src="images/A3/aruco/aruco_overlay.png" alt="h" width="450">
        <figcaption>with points</figcaption>
      </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/A3/aruco/aruco_warped_nearest.png" alt="h" width="450">
        <figcaption>nearest neighbor</figcaption>
      </figure>
      <figure>
        <img src="images/A3/aruco/aruco_warped_bilinear.png" alt="h" width="450">
        <figcaption>bilinear</figcaption>
      </figure>
      </div>



      <div class="image-row">
        <figure>
        <img src="images/A3/checker/original.JPG" alt="h" width="450">
        <figcaption>original</figcaption>
      </figure>
      <figure>
        <img src="images/A3/checker/checker_overlay.png" alt="h" width="450">
        <figcaption>with points</figcaption>
      </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/A3/checker/checker_warped_nearest.png" alt="h" width="450">
        <figcaption>nearest neighbor</figcaption>
      </figure>
      <figure>
        <img src="images/A3/checker/checker_warped_bilinear.png" alt="h" width="450">
        <figcaption>bilinear</figcaption>
      </figure>
      </div>

      <p class="row-caption">In terms of the tradeoff between nearest neighbor and bilinear interpolation, I found that bilinear interpolation was slightly slower in runtime, which makes sense because
        it has to do more calculations. However, there were slight improvements in quality of the images because bilinear interpolation takes into account the averaging between the surrounding pixels to be more representative. 
      </p>


      <h3 class="section-header">Part A.4: Blend the Images into a Mosaic</h3>

      <p class="row-caption">To perform mosaicing, I first computed the H matrices between the side images into the middle image. Then, I warped the side images so they became aligned with my
        center image. After that, I created a new canvas that could incorporate all 3 images. The masks for A, B, and C are then created by using a binary mask. With these images in their padded
        form, I then blended the 3 images together using a simple linear ramp mask. This means I found the point of intersection and I created a mask that gradually increases from 0 to 1 over a larger span.
      </p>

      <div class="image-row">
        <figure>
        <img src="images/A4/cory337B/IMG_8705.JPG" alt="h" width="450">
        <!-- <figcaption>original</figcaption> -->
      </figure>
      <figure>
        <img src="images/A4/cory337B/IMG_8703.JPG" alt="h" width="450">
        <!-- <figcaption>with
           points</figcaption> -->
      </figure>
      <figure>
        <img src="images/A4/cory337B/IMG_8702.JPG" alt="h" width="450">
        <!-- <figcaption>with
           points</figcaption> -->
      </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/A4/cory337B/8702_8703_8705_mosaic.jpg" alt="h" width="1000">
        <!-- <figcaption>original</figcaption> -->
      </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/A4/cory337D/IMG_8719.JPG" alt="h" width="450">
        <!-- <figcaption>original</figcaption> -->
      </figure>
      <figure>
        <img src="images/A4/cory337D/IMG_8720.JPG" alt="h" width="450">
        <!-- <figcaption>with
           points</figcaption> -->
      </figure>
      <figure>
        <img src="images/A4/cory337D/IMG_8721.JPG" alt="h" width="450">
        <!-- <figcaption>with
           points</figcaption> -->
      </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/A4/cory337D/8719_8720_8721_mosaic.jpg" alt="h" width="1000">
        <!-- <figcaption>original</figcaption> -->
      </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/A4/jacobs/IMG_8755.JPG" alt="h" width="450">
        <!-- <figcaption>original</figcaption> -->
      </figure>
      <figure>
        <img src="images/A4/jacobs/IMG_8756.JPG" alt="h" width="450">
        <!-- <figcaption>with
           points</figcaption> -->
      </figure>
      <figure>
        <img src="images/A4/jacobs/IMG_8757.JPG" alt="h" width="450">
        <!-- <figcaption>with
           points</figcaption> -->
      </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/A4/jacobs/8755_8756_8757_mosaic.jpg" alt="h" width="1000">
        <!-- <figcaption>original</figcaption> -->
      </figure>
      </div>

      <h3 class="section-header">Part B.1: Harris Corner Detection</h3>

      <p class="row-caption">In this section, I performed automatic corner detection using the Harris Corner Detector. This is done by computing the second moment matrix
        surrounding each pixel. This allows us to see the variation in intensity in both the x and y directions. If there is a high relative change in both directions, then
        the eigenvalues of this matrix will be large, indicating a corner. Otherwise, the eigenvalues will not reflect a corner there. We can use this to find what pixels
        are corners. In the images below, I computed the harris corners and selected the top 1000 corners based upon their corner response values.
      </p>

        <div class="image-row">
        <figure>
        <img src="images/B1/IMG_8720_corners_no_anms.png" alt="h" width="750">
        <figcaption>Image 1 Top 1000 corners without ANMS</figcaption>
      </figure>

        <figure>
        <img src="images/B1/IMG_8721_corners_no_anms.png" alt="h" width="750">
        <figcaption>Image 2 Top 1000 corners without ANMS</figcaption>
      </figure>
      </div>

      <h3 class="section-subheader">Adaptive Non-Maximal Suppression (ANMS)</h3>

      <p class="row-caption">daptive Non-Maximal Suppression (ANMS) is a technique for corner detection that enables us to get a much more uniform distribution of corners across the image.
        The idea is to suppress corners that are too close to each other, allowing only the strongest corners in a local neighborhood to be retained. This way, we have corners to utilize across the entire image, which helps us with image mosaicing when we may not have a large overlap between images. In the images below, I applied ANMS to the corners detected from the Harris Corner Detector and selected the top 1000 corners after applying ANMS. The algorihm for ANMS is as follows:
        1. For each corner, compute the minimum distance to a corner with at least 90% of its corner response value (90% is an arbitrary threshold chosen by the paper)
        2. Sort these corners based upon this minimum distance
        3. Select the top N corners based upon the minimum distance values found in step 1
      </p>

        <div class="image-row">
        <figure>
        <img src="images/B1/IMG_8720_corners_yes_anms.png" alt="h" width="750">
        <figcaption>Image 1 Top 1000 corners with ANMS</figcaption>
      </figure>

        <figure>
        <img src="images/B1/IMG_8721_corners_yes_anms.png" alt="h" width="750">
        <figcaption>Image 2 Top 1000 corners with ANMS</figcaption>
      </figure>
      </div>
  

      <h3 class="section-header">Part B.2: Feature Detector Extraction</h3>
      <p class="row-caption">Once we have corners, we need to extract feature descriptors that will help us match these corners to those in other images. To do this, we take a 40x40 patch around each detected corner. We downsample it to 8x8 by sampling every 5th pixel in both the x and y direction. The result is an 8x8 feature descriptor. Once we have this, we also normalize the patch by subtracting by the mean and dividing by the standard deviation. This ensures the contrast or gain of a specific portion of the image will not negatively affect our ability to match them together. Below is an image with its top 10 corners taken (without ANMS). Each feature descriptor is grayscaled, and it is also normalized. This will help us perform image feature descriptor comparisons later.</p>

      <div class="image-row">
        <figure>
        <img src="images/B2/IMG_8720_corners_no_anms_boxes.png" alt="h" width="1000">
        <figcaption>Image with Boxes for the Top 10 Patches</figcaption>
      </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/B2/IMG_8720_patches/0.png" alt="h" width="300">
        <figcaption>Patch 0</figcaption>
        </figure>


        <figure>
        <img src="images/B2/IMG_8720_patches/1.png" alt="h" width="300">
        <figcaption>Patch 1</figcaption>
        </figure>

        <figure>
        <img src="images/B2/IMG_8720_patches/2.png" alt="h" width="300">
        <figcaption>Patch 2</figcaption>
        </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/B2/IMG_8720_patches/3.png" alt="h" width="300">
        <figcaption>Patch 3</figcaption>
        </figure>


        <figure>
        <img src="images/B2/IMG_8720_patches/4.png" alt="h" width="300">
        <figcaption>Patch 4</figcaption>
        </figure>

        <figure>
        <img src="images/B2/IMG_8720_patches/5.png" alt="h" width="300">
        <figcaption>Patch 5</figcaption>
        </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/B2/IMG_8720_patches/6.png" alt="h" width="300">
        <figcaption>Patch 6</figcaption>
        </figure>


        <figure>
        <img src="images/B2/IMG_8720_patches/7.png" alt="h" width="300">
        <figcaption>Patch 7</figcaption>
        </figure>

        <figure>
        <img src="images/B2/IMG_8720_patches/8.png" alt="h" width="300">
        <figcaption>Patch 8</figcaption>
        </figure>
      </div>

            <div class="image-row">
        <figure>
        <img src="images/B2/IMG_8720_patches/9.png" alt="h" width="300">
        <figcaption>Patch 9</figcaption>
        </figure>

      </div>

      <h3 class="section-header">Part B.3: Feature Descriptor Matching</h3>
      <p class="row-caption">Once we have all the image patches, we can begin corner matching. To do this, I took every feature descriptor from one image and compared it to every feature descriptor in the other image using the sum of squared differences (SSD) as a measure of similarity. The top matches are then selected based on the lowest SSD values. 
        This is a relatively slow algorithm since I have to compare every feature descriptor in image 1 to every feature descriptor in image 2, but it is an effective algorithm nonetheless. This works because I have normalized the feature descriptors, so even if they are different lighting, we will still be able to match them. I used Lowe's technique, outlined in the paper, to score the confidence in my match. Instead of simply looking at the error of the best match, we find the ratio between the best match and the second best match. If this ratio is below a certain threshold, we can state that the best match is significantly better than the second best match, so we can accept it as a good match. Otherwise, there are many places this corner can map to, and we cannot be confident in our decision. This helps eliminate many false matches that may occur due to repetitive patterns in the image. Below are the top 20 matches found between the 2 images along with their ratio images. I have also included the normalized patches for these top 20 corner matches. The indexing goes to 1000 since I was using the top 1000 corners found for each image. We see that most corners are matched well, but there are a couple that do not match at all. This is probably due to repetitive patterns found within the image.
      </p>
      <div class="image-row">
        <figure>
        <img src="images/B3/IMG_8720_correspondences.png" alt="h" width="750">
        <figcaption>img1 top 20 matches</figcaption>
        </figure>

        <figure>
        <img src="images/B3/IMG_8721_correspondences.png" alt="h" width="750">
        <figcaption>img2 top 20 matches</figcaption>
        </figure>

      </div>

        <div class="image-row">
        <figure>
        <img src="images/B3/correspondences/match_10_3_ratio.png" alt="h" width="450">
        <!-- <figcaption></figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_11_5_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_183_790_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/B3/correspondences/match_191_505_ratio.png" alt="h" width="450">
        <!-- <figcaption></figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_207_173_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_229_823_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/B3/correspondences/match_256_668_ratio.png" alt="h" width="450">
        <!-- <figcaption></figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_265_191_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_271_846_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/B3/correspondences/match_295_883_ratio.png" alt="h" width="450">
        <!-- <figcaption></figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_29_34_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_338_730_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/B3/correspondences/match_347_276_ratio.png" alt="h" width="450">
        <!-- <figcaption></figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_361_693_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_375_98_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/B3/correspondences/match_42_38_ratio.png" alt="h" width="450">
        <!-- <figcaption></figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_447_436_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_469_707_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/B3/correspondences/match_611_982_ratio.png" alt="h" width="450">
        <!-- <figcaption></figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_679_958_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_75_74_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>
      </div>

      <div class="image-row">
        <figure>
        <img src="images/B3/correspondences/match_828_869_ratio.png" alt="h" width="450">
        <!-- <figcaption></figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_89_454_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>

        <figure>
        <img src="images/B3/correspondences/match_938_929_ratio.png" alt="h" width="450">
        <!-- <figcaption>img2 top 20 matches</figcaption> -->
        </figure>
      </div>

      <h3 class="section-header">Part B.4: RANSAC for Robust Homography</h3>
      <p class="row-caption">Once we have many possible point correspondences, some may be accurate and some may not be. We want to find the best homography that accounts for the outliers. To do this, we use RANSAC (Random Sample Consensus), which iteratively selects a random subset of correspondences, computes a homography, and then counts how many correspondences agree with this homography. This algorithm is run for thousands of iterations. Every iteration, we randomly sample 4 point correspondences. We compute the homography between these points and determine how many correspondences are inliers. The homography with the most inliers is chosen as the best estimate. This allows us to automatically find the best homogrpahy between two images, and subsequently warp the images onto one another in the most accurate way possible with the information available. Below are the same mosaics I produced for part A, side by side with the automatic mosaics produced in part B. We see some improvements in image clarity (ie the words "Jacobs Hall" in the third image), which indicates this algorithm has found a more accurate homography than my manual point selection.</p>

      <h3 class="section-subheader">Cory 337B</h3>
      <div class="image-row">
        <figure>
        <img src="images/A4/cory337B/8702_8703_8705_mosaic.jpg" alt="h" width="750">
        <figcaption>Manual Image Mosaicing</figcaption>
        </figure>

        <figure>
        <img src="images/B4/IMG_8705_IMG_8703_IMG_8702_mosaic_ransac.jpg" alt="h" width="750">
        <figcaption>RANSAC Image Mosaicing</figcaption>
        </figure>

      </div>
    
      <h3 class="section-subheader">Cory 337D</h3>
      <div class="image-row">
        <figure>
        <img src="images/A4/cory337D/8719_8720_8721_mosaic.jpg" alt="h" width="750">
        <figcaption>Manual Image Mosaicing</figcaption>
        </figure>

        <figure>
        <img src="images/B4/IMG_8719_IMG_8720_IMG_8721_mosaic_ransac.jpg" alt="h" width="750">
        <figcaption>RANSAC Image Mosaicing</figcaption>
        </figure>

      </div>

      <h3 class="section-subheader">Jacobs</h3>
      <div class="image-row">
        <figure>
        <img src="images/A4/jacobs/8755_8756_8757_mosaic.jpg" alt="h" width="750">
        <figcaption>Manual Image Mosaicing</figcaption>
        </figure>

        <figure>
        <img src="images/B4/IMG_8755_IMG_8756_IMG_8757_mosaic_ransac.jpg" alt="h" width="750">
        <figcaption>RANSAC Image Mosaicing</figcaption>
        </figure>

      </div>

</body>
</html>